// Generated by CoffeeScript 1.10.0
(function() {
  var start;

  start = function(ready) {
    var addUtilities, async, config, conn, connectToDatabase, createDirectories, getLogger, logger, models, startWebApp, utilities;
    async = require('async');
    config = require('./server-config.json');
    getLogger = function(name, level) {
      var log4js, logger, path;
      log4js = require('log4js');
      path = require('path');
      log4js.configure({
        appenders: [
          {
            type: 'console'
          }, {
            type: 'file',
            filename: 'logs' + path.sep + config.logger.filename,
            category: name
          }
        ]
      });
      logger = log4js.getLogger(name);
      logger.setLevel(level);
      return logger;
    };
    logger = getLogger('market-server', config.logger.level);
    conn = {};
    models = {};
    utilities = {
      checkIsAdmin: function(bankid) {
        var admins;
        admins = config.admins;
        if ((admins.indexOf(bankid)) > -1) {
          return true;
        }
        return false;
      },
      checkMoneySource: function(bankid) {
        var sources;
        sources = config.money_source;
        if ((sources.indexOf(bankid)) > -1) {
          return true;
        }
        return false;
      },
      checkMoneyVoid: function(bankid) {
        var voids;
        voids = config.money_void;
        if ((voids.indexOf(bankid)) > -1) {
          return true;
        }
        return false;
      },
      displayUser: function(username, bankid) {
        return username + ' (#' + bankid + ')';
      },
      isValidUsernameFormat: function(username) {
        var max_length, min_length;
        min_length = 3;
        max_length = 16;
        if (!/^[a-zA-Z0-9_]*$/g.test(username)) {
          return false;
        }
        if (!(username.length >= min_length && username.length <= max_length)) {
          return false;
        }
        return true;
      },
      isValidBankIdFormat: function(bankid) {
        var max_length, min_length;
        min_length = 3;
        max_length = 16;
        if (!/^[a-zA-Z0-9_]*$/g.test(bankid)) {
          return false;
        }
        if (!(bankid.length >= min_length && bankid.length <= max_length)) {
          return false;
        }
        return true;
      },
      calculateTax: function(amount) {
        return Math.ceil(parseFloat(amount) * config.tax.rate * 100) / 100;
      },
      calculateTotal: function(amount) {
        return amount + calculateTax(amount);
      }
    };
    createDirectories = function(callback) {
      var createDirectory, fs, required_directories;
      fs = require('fs-extra');
      required_directories = ['user-content/item-images'];
      createDirectory = function(directory, callback) {
        return fs.ensureDir(directory, function(err) {
          if (err != null) {
            logger.error(err);
          }
          return callback();
        });
      };
      return async.each(required_directories, createDirectory, function() {
        logger.info('Created required directories');
        return callback();
      });
    };
    connectToDatabase = function(callback) {
      var Schema, database_url, mongoose, schemas, setModels, setSchemas;
      mongoose = require('mongoose');
      Schema = mongoose.Schema;
      conn = mongoose.connection;
      schemas = {};
      setSchemas = function() {
        schemas.items = new Schema({
          id: String,
          owner: String,
          name: String,
          price: Number,
          quantity: Number,
          instructions: Number,
          image: String,
          forSale: Boolean,
          quicklink: String
        }, {
          collection: 'items'
        });
        schemas.transactions = new Schema({
          from: String,
          to: String,
          date: Date,
          amount: Number,
          memo: String,
          generated: Boolean
        }, {
          collection: 'transactions'
        });
        schemas.users = new Schema({
          id: String,
          username: String,
          username_lower: String,
          bankid: String,
          password: String,
          balance: Number,
          tagline: String,
          trusted: Boolean,
          taxExempt: Boolean
        }, {
          collection: 'users'
        });
        schemas.quicklinks = new Schema({
          link: String,
          item: String,
          payment: {
            to: String,
            amount: Number,
            memo: String
          }
        }, {
          collection: 'quicklinks'
        });
        return schemas.receipts = new Schema({
          id: String,
          proof: String,
          buyer: String,
          seller: String,
          recipient: String,
          date: Date,
          items: {
            name: String,
            quantity: Number,
            description: String,
            instructions: String
          }
        }, {
          collection: 'receipts'
        });
      };
      setSchemas();
      setModels = function() {
        models.users = mongoose.model('user', schemas.users);
        models.items = mongoose.model('items', schemas.items);
        models.transactions = mongoose.model('transactions', schemas.transactions);
        models.quicklinks = mongoose.model('quicklinks', schemas.quicklinks);
        return models.receipts = mongoose.model('receipts', schemas.receipts);
      };
      setModels();
      database_url = 'mongodb://' + config.mongodb.host + ':' + config.mongodb.port + '/' + config.mongodb.database;
      logger.debug('Connecting to database ' + database_url);
      mongoose.connect(database_url);
      conn.once('error', function(err) {
        callback(err);
        throw err;
      });
      return conn.once('open', function() {
        logger.info('Successfully connected to database');
        return callback();
      });
    };
    addUtilities = function(callback) {
      var addTaxRecipient;
      utilities.idToUser = function(id, callback) {
        return models.users.findOne({
          id: id
        }).lean().exec(function(err, user) {
          return callback(user);
        });
      };
      utilities.nameToUser = function(name, callback) {
        if ((name.charAt(0)) === '#') {
          return models.users.findOne({
            bankid: name.toLowerCase().substring(1)
          }).exec(function(err, user) {
            return callback(user);
          });
        } else {
          return models.users.findOne({
            username_lower: name.toLowerCase()
          }).exec(function(err, user) {
            return callback(user);
          });
        }
      };
      utilities.isUsernameAvailable = function(username, callback) {
        return models.users.findOne({
          username: username
        }).lean().exec(function(err, user) {
          if (user != null) {
            return callback(false);
          } else {
            return callback(true);
          }
        });
      };
      utilities.hasEnoughFunds = function(user, amount) {
        if ((user.balance / 100) >= amount) {
          return true;
        }
        return false;
      };
      utilities.sendMoney = function(from, to, amount, memo, callback) {
        var getFrom, getTo, transferMoney;
        getFrom = function(callback) {
          return utilities.nameToUser(from, function(user) {
            from = user;
            return callback();
          });
        };
        getTo = function(callback) {
          return utilities.nameToUser(to, function(user) {
            to = user;
            return callback();
          });
        };
        transferMoney = function(callback) {
          var adjustBalance, makePayment;
          if (hasEnoughFunds(from, calculateTotal(amount))) {
            adjustBalance = function(user, change, callback) {
              user.balance = user.balance + change;
              return user.save(callback);
            };
            makePayment = function(from, to, amount, memo, generated, callback) {
              return async.parallel([
                function(callback) {
                  return adjustBalance(from, -1 * amount, callback);
                }, function(callback) {
                  return adjustBalance(to, amount, callback);
                }, function(callback) {
                  var transaction;
                  transaction = new models.transactions({
                    from: from._id,
                    to: to._id,
                    amount: amount,
                    memo: memo,
                    date: Date.now(),
                    generated: generated
                  });
                  return transaction.save(callback);
                }
              ]);
            };
            return async.parallel([]);
          } else {
            return callback('Not enough funds');
          }
        };
        return async.series([getFrom, getTo, transferMoney], callback);
      };
      addTaxRecipient = function(callback) {
        return models.users.findOne({
          bankid: config.tax.recipient
        }).exec(function(err, user) {
          if (user != null) {
            utilities.tax_recipient = user;
          } else {
            logger.warn('Tax recipient user could not be found');
          }
          return callback();
        });
      };
      return async.parallel([addTaxRecipient], callback);
    };
    startWebApp = function(callback) {
      var app, configureExpress, express, passwordHasher, startWebServer;
      express = require('express');
      app = express();
      passwordHasher = require('password-hash-and-salt');
      configureExpress = function(callback) {
        var LocalStrategy, bodyParser, fieldSelector, flash, passport, session;
        session = require('express-session');
        app.use(session({
          secret: 'keyboard cat',
          resave: true,
          saveUninitialized: false
        }));
        passport = require('passport');
        LocalStrategy = require('passport-local').Strategy;
        passport.use(new LocalStrategy({
          passReqToCallback: true
        }, function(req, username, password, done) {
          var getUser, loginFail, user, verifyPassword;
          username = username.toLowerCase();
          user = {};
          loginFail = function() {
            logger.info(username + ' failed to log in');
            return done(null, false, {
              message: 'Incorrect username or password'
            });
          };
          getUser = function(callback) {
            if (username.substring(0, 1 === '#')) {
              return models.users.findOne({
                bankid: username.substring(1)
              }, function(err, found_user) {
                if (err != null) {
                  logger.error(err);
                  return callback(err);
                } else {
                  user = found_user;
                  return callback();
                }
              });
            } else {
              return models.users.findOne({
                username_lower: username.toLowerCase()
              }, function(err, found_user) {
                if (err != null) {
                  logger.error(err);
                  loginFail();
                  return callback(err);
                } else {
                  if (found_user) {
                    user = found_user;
                    return callback();
                  } else {
                    loginFail();
                    return callback('failed to log in');
                  }
                }
              });
            }
          };
          verifyPassword = function(callback) {
            return passwordHasher(password).verifyAgainst(user.password, function(err, verified) {
              if (err != null) {
                logger.error(err);
                loginFail();
                return callback(err);
              } else {
                if (verified) {
                  logger.info(username + ' successfully logged in');
                  done(null, user);
                  return callback();
                } else {
                  loginFail();
                  return callback('failed to login');
                }
              }
            });
          };
          return async.series([getUser, verifyPassword]);
        }));
        passport.serializeUser(function(user, done) {
          return done(null, user._id);
        });
        passport.deserializeUser(function(id, done) {
          return models.users.findOne({
            _id: id
          }, function(err, user) {
            return done(err, user);
          });
        });
        app.use(passport.initialize());
        app.use(passport.session());
        bodyParser = require('body-parser');
        app.use(bodyParser.json({
          limit: '5mb'
        }));
        app.use(bodyParser.urlencoded({
          limit: '5mb',
          extended: true
        }));
        flash = require('connect-flash');
        app.use(flash());
        fieldSelector = require('./field-selector');
        session = require('express-session');
        app.use(session({
          secret: 'keyboard cat',
          resave: true,
          saveUninitialized: false
        }));
        app.use('/static', express["static"]('webcontent'));
        app.get('/api/config', function(req, res) {
          res.set('Content-Type', 'text/json');
          return res.send(fieldSelector.selectWithQueryString(req.query.fields, {
            title: config.page_text.title,
            footer: config.page_text.footer,
            captcha_site_key: config.captcha.site_key
          }));
        });
        app.post('/api/signin', passport.authenticate('local', {
          successRedirect: '/#/profile',
          failureRedirect: '/signin',
          failureFlash: true
        }));
        app.post('/api/createaccount', function(req, res) {
          var createAccount, respond, verifyCaptcha;
          respond = function(status) {
            if (status.success) {
              logger.info(req.ip + ' created a new account');
              return res.redirect('/signin');
            } else {
              req.flash('message', status.message);
              return res.redirect('/createaccount');
            }
          };
          verifyCaptcha = function(callback) {
            var recaptcha_response, request;
            if (!config.captcha.enabled) {
              return callback();
            } else {
              request = require('request');
              recaptcha_response = req.body['g-recaptcha-response'];
              return request.post('https://www.google.com/recaptcha/api/siteverify', {
                form: {
                  secret: config.captcha.secret_key,
                  response: recaptcha_response
                }
              }, function(err, res, body) {
                body = JSON.parse(body);
                if (body.success) {
                  return callback();
                } else {
                  respond({
                    success: false,
                    message: 'Could not verify captcha'
                  });
                  return callback('Could not verify captcha');
                }
              });
            }
          };
          createAccount = function(callback) {
            var createUser, hashPassword;
            logger.trace('Creating an account...');
            hashPassword = function(callback) {
              return passwordHasher(req.body['password']).hash(function(err, hash) {
                if (err != null) {
                  return callback(err);
                } else {
                  logger.trace('Hashed password');
                  return callback(null, hash);
                }
              });
            };
            createUser = function(credentials, callback) {
              var saveUser, verifyCredentials;
              verifyCredentials = function(credentials, callback) {
                var bankid, username;
                logger.trace('Verifying credentials...');
                bankid = credentials.bankid;
                username = credentials.username;
                if (!(utilities.isValidBankIdFormat(bankid))) {
                  return callback('Invalid Bank ID');
                }
                if (!(utilities.isValidUsernameFormat(username))) {
                  return callback('Invalid username');
                }
                logger.trace('Credentials meet requirements, now checking if available...');
                return models.users.findOne({
                  $or: [
                    {
                      username_lower: username.toLowerCase()
                    }, {
                      bankid: bankid
                    }
                  ]
                }).lean().count(function(err, count) {
                  logger.trace('Count obtained and is ' + count);
                  if (count > 0) {
                    logger.trace('Username or Bank ID is taken');
                    return callback('Username or Bank ID is taken');
                  } else {
                    logger.trace('Credentials verified');
                    return callback();
                  }
                });
              };
              saveUser = function(credentials, callback) {
                var user;
                logger.trace('Saving user to database...');
                user = new models.users({
                  username: credentials.username,
                  username_lower: credentials.username.toLowerCase(),
                  password: credentials.password_hash,
                  bankid: credentials.bankid,
                  balance: 0,
                  tagline: config.default_tagline,
                  trusted: false,
                  taxExempt: false
                });
                return user.save(function(err) {
                  if (err != null) {
                    logger.error('Error saving to database: ' + err);
                    return callback(err);
                  } else {
                    logger.trace('User saved to database');
                    return callback();
                  }
                });
              };
              return verifyCredentials(credentials, function(err) {
                if (err != null) {
                  return respond({
                    success: false,
                    message: err
                  });
                } else {
                  return saveUser(credentials, function(err) {
                    if (err != null) {
                      return respond({
                        success: false,
                        message: err
                      });
                    } else {
                      logger.debug('Account created for ' + credentials.username);
                      return callback();
                    }
                  });
                }
              });
            };
            return async.waterfall([
              hashPassword, function(hash, callback) {
                return createUser({
                  username: req.body.username.trim(),
                  password_hash: hash,
                  bankid: req.body.bankid.toLowerCase().trim()
                }, callback);
              }
            ], callback);
          };
          return async.series([verifyCaptcha, createAccount], function() {
            return respond({
              success: true
            });
          });
        });
        app.post('/api/send', function(req, res) {
          res.set('Content-Type', 'text/json');
          if (req.user != null) {
            return res.send({
              success: false,
              message: 'Not yet implemented'
            });
          } else {
            return res.send({
              success: false,
              message: 'Not signed in'
            });
          }
        });
        app.post('/api/account/username', function(req, res) {
          res.set('Content-Type', 'text/json');
          if (req.user != null) {
            if (!(utilities.isValidUsernameFormat(req.body.username))) {
              return res.send({
                success: false,
                message: 'Invalid username'
              });
            }
            return utilities.isUsernameAvailable(req.body.username, function(result) {
              if (result) {
                return models.users.findOne({
                  _id: req.user._id
                }).exec(function(err, user) {
                  if (user != null) {
                    user.username = req.body.username;
                    return user.save(function() {
                      return res.send({
                        success: true
                      });
                    });
                  } else {
                    return res.send({
                      success: false,
                      message: 'Could not find user in database'
                    });
                  }
                });
              } else {
                return res.send({
                  success: false,
                  message: 'Username not available'
                });
              }
            });
          } else {
            return res.send({
              success: false,
              message: 'Not signed in'
            });
          }
        });
        app.post('/api/account/password', function(req, res) {
          res.set('Content-Type', 'text/json');
          if (req.user != null) {
            return models.users.findOne({
              _id: req.user._id
            }).exec(function(err, user) {
              if (user != null) {
                return passwordHasher(req.body.password).hash(function(err, hash) {
                  if (err != null) {
                    return res.send({
                      success: false,
                      message: 'Error hashing password'
                    });
                  } else {
                    logger.trace('Hashed password');
                    user.password = hash;
                    return user.save(function() {
                      return res.send({
                        success: true
                      });
                    });
                  }
                });
              } else {
                return res.send({
                  success: false,
                  message: 'Could not find user in database'
                });
              }
            });
          } else {
            return res.send({
              success: false,
              message: 'Not signed in'
            });
          }
        });
        app.get('/api/buy', function(req, res) {
          var limit, skip;
          res.set('Content-Type', 'text/json');
          limit = req.query.limit != null ? parseInt(req.query.limit) : null;
          skip = req.query.skip != null ? parseInt(req.query.skip) : 0;
          return models.items.find({
            forSale: true
          }).skip(skip).limit(limit).lean().exec(function(err, data) {
            var convertIdToUsername;
            if (data != null) {
              convertIdToUsername = function(item, callback) {
                return utilities.idToUser(item.owner, function(user) {
                  if (user != null) {
                    item.owner = user.username;
                  }
                  return callback();
                });
              };
              return async.each(data, convertIdToUsername, function() {
                return res.send(data);
              });
            } else {
              return res.send([]);
            }
          });
        });
        app.get('/api/items', function(req, res) {
          var limit, skip;
          res.set('Content-Type', 'text/json');
          if (req.user != null) {
            limit = req.query.limit != null ? parseInt(req.query.limit) : null;
            skip = req.query.skip != null ? parseInt(req.query.skip) : 0;
            return models.items.find({
              owner: req.user.id
            }).skip(skip).limit(limit).lean().exec(function(err, data) {
              if (data != null) {
                return res.send(data);
              } else {
                return res.send([]);
              }
            });
          } else {
            return res.send(null);
          }
        });
        app.get('/api/user', function(req, res) {
          var taxRate;
          res.set('Content-Type', 'text/json');
          if (req.user != null) {
            taxRate = config.tax.rate;
            if (req.user.taxExempt) {
              taxRate = 0;
            }
            return res.send(fieldSelector.selectWithQueryString(req.query.fields, {
              id: req.user._id,
              username: req.user.username,
              bankid: req.user.bankid,
              balance: req.user.balance / 100,
              tagline: req.user.tagline,
              taxRate: taxRate,
              isAdmin: utilities.checkIsAdmin(req.user.bankid),
              trusted: req.user.trusted,
              taxExempt: req.user.taxExempt,
              isMoneySource: utilities.checkMoneySource(req.user.bankid),
              isMoneyVoid: utilities.checkMoneyVoid(req.user.bankid)
            }));
          } else {
            return res.send(null);
          }
        });
        app.get('/api/users', function(req, res) {
          var limit, skip;
          res.set('Content-Type', 'text/json');
          limit = req.query.limit != null ? parseInt(req.query.limit) : null;
          skip = req.query.skip != null ? parseInt(req.query.skip) : 0;
          return models.users.find({}).sort({
            balance: -1
          }).skip(skip).limit(limit).select('_id username bankid tagline balance trusted taxExempt').lean().exec(function(err, data) {
            var i, len, user;
            if (data != null) {
              for (i = 0, len = data.length; i < len; i++) {
                user = data[i];
                user.balance = user.balance / 100;
              }
              return res.send(data);
            } else {
              return res.send([]);
            }
          });
        });
        app.get('/api/receipts', function(req, res) {
          var limit, skip;
          res.set('Content-Type', 'text/json');
          if (req.user == null) {
            return res.send(null);
          }
          limit = req.query.limit != null ? parseInt(req.query.limit) : null;
          skip = req.query.skip != null ? parseInt(req.query.skip) : 0;
          return models.receipts.find({
            $or: [
              {
                buyer: req.user.id
              }, {
                seller: req.user.id
              }
            ]
          }).sort({
            date: -1
          }).skip(skip).limit(limit).lean().exec(function(err, data) {
            var convertIdToUsername;
            if (data != null) {
              convertIdToUsername = function(receipt, callback) {
                var convertBuyer, convertDate, convertSeller;
                convertDate = function(callback) {
                  receipt.date = new Date(receipt.date).toString();
                  return callback();
                };
                convertBuyer = function(callback) {
                  return utilities.idToUser(receipt.buyer, function(user) {
                    receipt.buyer = {
                      username: user.username,
                      bankid: user.bankid
                    };
                    return callback();
                  });
                };
                convertSeller = function(callback) {
                  return utilities.idToUser(receipt.seller, function(user) {
                    receipt.seller = {
                      username: user.username,
                      bankid: user.bankid
                    };
                    return callback();
                  });
                };
                return async.parallel([convertDate, convertBuyer, convertSeller], callback);
              };
              return async.each(data, convertIdToUsername, function() {
                return res.send(data);
              });
            } else {
              return res.send([]);
            }
          });
        });
        app.get('/api/transactions', function(req, res) {
          var limit, skip;
          res.set('Content-Type', 'text/json');
          if (req.user == null) {
            return res.send(null);
          }
          limit = req.query.limit != null ? parseInt(req.query.limit) : null;
          skip = req.query.skip != null ? parseInt(req.query.skip) : 0;
          return models.transactions.find({
            $or: [
              {
                to: req.user.id
              }, {
                from: req.user.id
              }
            ]
          }).sort({
            date: -1
          }).skip(skip).limit(limit).lean().exec(function(err, data) {
            var convertIdToUsername;
            if (data != null) {
              convertIdToUsername = function(transaction, callback) {
                var convertFrom, convertTo;
                convertTo = function(callback) {
                  return utilities.idToUser(transaction.to, function(user) {
                    transaction.to = {
                      username: user.username,
                      bankid: user.bankid
                    };
                    return callback();
                  });
                };
                convertFrom = function(callback) {
                  return utilities.idToUser(transaction.from, function(user) {
                    transaction.from = {
                      username: user.username,
                      bankid: user.bankid
                    };
                    return callback();
                  });
                };
                return async.parallel([convertTo, convertFrom], callback);
              };
              return async.each(data, convertIdToUsername, function() {
                return res.send(data);
              });
            } else {
              return res.send([]);
            }
          });
        });
        app.get('/signin', function(req, res) {
          if (req.user == null) {
            return res.render('signin.jade', {
              message: req.flash('error'),
              title: config.page_text.title,
              footer: config.page_text.footer
            });
          } else {
            return res.redirect('/');
          }
        });
        app.get('/signout', function(req, res) {
          if (req.user != null) {
            logger.info(utilities.displayUser(req.user.username, req.user.bankid) + ' signed out from ' + req.ip);
            req.logout();
          }
          return res.redirect('/signin');
        });
        app.get('/createaccount', function(req, res) {
          var captchadisplay, captchakey;
          if (req.user == null) {
            captchadisplay = config.captcha.enabled ? 'inline' : 'none';
            captchakey = config.captcha.site_key ? config.captcha_site_key : 'none';
            return res.render('createaccount.jade', {
              message: req.flash('message'),
              username: req.flash('username'),
              bankid: req.flash('bankid'),
              captchadisplay: captchadisplay,
              captchakey: captchakey,
              title: config.page_text.title,
              footer: config.page_text.footer
            });
          } else {
            return res.redirect('/');
          }
        });
        app.get('/', function(req, res) {
          if (req.user != null) {
            return res.render('index.jade');
          } else {
            return res.redirect('/signin');
          }
        });
        app.get('/jade/:name', function(req, res) {
          if (req.user != null) {
            return res.render(req.params.name, {
              title: config.page_text.title,
              bankid: req.user.bankid
            });
          } else {
            return res.redirect('/signin');
          }
        });
        return callback();
      };
      startWebServer = function(callback) {
        var fs, https_options, logReadyMessage, startHttpServer, startHttpolyglotServer, startHttpsServer;
        logReadyMessage = function(port, protocol) {
          return logger.info('Server listening on port ' + port + ' (' + protocol + ')');
        };
        startHttpServer = function(callback) {
          var http, http_server;
          http = require('http');
          http_server = http.createServer(app);
          return http_server.listen(config.port.http, function() {
            logReadyMessage(config.port.http, 'http');
            return callback();
          });
        };
        if (config.https.enabled) {
          fs = require('fs');
          https_options = {
            key: fs.readFileSync(config.https.key),
            cert: fs.readFileSync(config.https.cert),
            ciphers: 'HIGH'
          };
          startHttpsServer = function(callback) {
            var https, https_server;
            https = require('https');
            https_server = https.createServer(https_options, app);
            return https_server.listen(config.port.https, function() {
              logReadyMessage(config.port.https, 'https');
              return callback();
            });
          };
          startHttpolyglotServer = function(callback) {
            var httpolyglot, httpolyglot_server;
            httpolyglot = require('httpolyglot');
            httpolyglot_server = httpolyglot.createServer(https_options, app);
            return httpolyglot_server.listen(config.port.https, function() {
              logReadyMessage(config.port.http, 'http');
              logReadyMessage(config.port.https, 'https');
              return callback();
            });
          };
          if (config.port.http === config.port.https) {
            return async.parallel([startHttpolyglotServer], callback);
          } else {
            return async.parallel([startHttpServer, startHttpServer], callback);
          }
        } else {
          return async.parallel([startHttpServer], callback);
        }
      };
      return async.series([configureExpress, startWebServer], callback);
    };
    return async.series([
      createDirectories, connectToDatabase, addUtilities, startWebApp, function(callback) {
        logger.info('Server startup complete');
        return callback();
      }
    ], ready);
  };

  module.exports.start = start;

}).call(this);
